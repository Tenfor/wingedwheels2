local druid = require("druid.druid")
local rich_input = require("druid.custom.rich_input.rich_input")
local const  = require("druid.const")
local gameModel =require "main/game/gameModel"
local json = require("main/json")
local upgrades  = require "main/game/upgrades"
local gameSettings = require("main/gameSettings")
local bridge = require("bridge.bridge")


local function translateToRussian(self)
	local titleText = gui.get_node("title")
	gui.set_font(titleText, "rufont")
	gui.set_text(titleText, "Игра окончена")

	local yourScoresText = gui.get_node("title1")
	gui.set_font(yourScoresText, "rufont")
	gui.set_text(yourScoresText, "Твои результаты:")

	local cheering = gui.get_node("cheering")
	gui.set_font(cheering, "rufont")
	gui.set_text(cheering, "Ты справишься!")

	local collectedCoinsText = gui.get_node("text3")
	gui.set_font(collectedCoinsText, "rufont")
	gui.set_text(collectedCoinsText, "Вы собрали ".. tostring(gameModel.currentScores) .." монет")

	local continueText = gui.get_node("text1")
	gui.set_font(continueText, "rufont")
	gui.set_text(continueText, "Далее")

	local submitText = gui.get_node("text")
	gui.set_font(submitText, "rufont")
	gui.set_text(submitText, "Отправить")
end

local function hideSuccessIcon(self)
	gui.set_alpha(self.successIcon, 0)
end

local function showSuccessIcon(self,success)
	gui.set_alpha(self.successIcon, 1)
	local label = "xIcon"
	if success then 
		label = "tickIcon"
	end
	gui.play_flipbook(self.successIcon, label)
end

local function hideDescriptionText(self)
	gui.set_alpha(self.descriptionTextNode, 0)
end

local function setDescriptionText(self,text,center,ruText)

	local pos = gui.get_position(self.descriptionTextNode)
	if(center) then
		gui.set_alpha(self.cheeringTextNode, 1)
		pos.y = 426
	else
		gui.set_alpha(self.cheeringTextNode, 0)
		pos.y = 240
	end
	gui.set_position(self.descriptionTextNode, pos)
	
	gui.set_alpha(self.descriptionTextNode, 1)
	gui.set_text(self.descriptionTextNode, text)

	if gameSettings.lang == "ru" then 
		gui.set_font(self.descriptionTextNode, "rufont")
		gui.set_text(self.descriptionTextNode, ruText)
	end
end

local function setLoadingText(self, text, ruText)
	gui.set_text(self.loadingTextNode, text)
	gui.animate(self.loadingTextNode, "color.w", 1, gui.EASING_LINEAR, 1,0,nil,gui.PLAYBACK_LOOP_PINGPONG)

	if gameSettings.lang == "ru" then 
		gui.set_font(self.loadingTextNode, "rufont")
		gui.set_text(self.loadingTextNode, ruText)
	end

end

local function hideLoadingText(self)
	gui.cancel_animation(self.loadingTextNode, "color.w")
	gui.set_alpha(self.loadingTextNode, 0)
end

local function hideInput(self)
	gui.set_enabled(self.rich_input_parent, false)
	gui.set_alpha(self.rich_input_parent, 0)
	gui.set_enabled(self.submitButtonNode, false)
end

local function showInput(self)
	gui.set_enabled(self.rich_input_parent, true)
	gui.set_alpha(self.rich_input_parent, 1)
	gui.set_enabled(self.submitButtonNode, true)
end

local function handle_fetch_response(self,id,response)
	hideLoadingText(self)
	if response.status == 200 or response.status == 304 then
		local decodedResponse = json.decode(response.response)
		local minScore = 0
		if #decodedResponse >= 50 then
			minScore = decodedResponse[50].scores
		end
		if gameModel.currentScores > minScore then
			setDescriptionText(self, "Congratulation!\nNew Highscore!",false, "Поздравляем!\nНовый рекорд!")
			self.rich_input:set_placeholder("Enter Your Name")
			if gameSettings.lang == "ru" then 
				self.rich_input:set_placeholder("Ваше имя")
			end

			if gameSettings.playerName ~= "" then
				self.rich_input:set_placeholder("")
				self.rich_input.input:set_text(gameSettings.playerName)
			end
			
			showInput(self)
		else
			setDescriptionText(self, "Reach "..tostring(minScore+1).."\nfor a new Highscore", true, "Нужно "..tostring(minScore+1).."\nдля рекорда" )
		end
	else
		showSuccessIcon(self,false)
		setDescriptionText(self, "Connection Error",false,"Ошибка сети")
	end
end

local function handle_post_response(self, id, response)
	hideLoadingText(self)
	if response.status == 200 then 
		showSuccessIcon(self,true)
		setDescriptionText(self, "Scores submitted!\nCongratulations!", false, "Рекорд Отправлено!\nПоздравления!")
	else
		showSuccessIcon(self,false)
		setDescriptionText(self, "Connection error!", false, "Ошибка сети")
		timer.delay(3, false, function()
			hideSuccessIcon(self)
			setDescriptionText(self, "Congratulation!\nNew Highscore!", false, "Поздравления!\nНовый рекорд!")
			--hideDescriptionText(self)
			showInput(self)
		end)
	end
end

local function onSubmit(self)
	local playerName = self.rich_input:get_text()
	if #playerName > 0 then
		msg.post("soundController", "playSfx", {url="#tick"})
		setLoadingText(self,"Submitting score...", "Отправка рекорда...")
		hideInput(self)
		hideDescriptionText(self)

		bridge.storage.set ({ 
			playerName = playerName
		},
		function ()
			gameSettings.setPlayerName(playerName)
		end
		)

		local headers = {
			["Content-Type"] = "application/json"
		}
		--local body = '{"playerName":"Test"}'
		local body = json.encode({playerName=self.rich_input:get_text(),scores=gameModel.currentScores})
		http.request("https://tgapi-zhv2.onrender.com/scores", "POST", handle_post_response, headers, body)
		--http.request("http://localhost:3000", "POST", handle_response, headers, body2)
	else
		msg.post("soundController", "playSfx", {url="#lock"})
	end
end

local function showAdPanel(self)
	gui.set_enabled(self.basePanel, false)
	gui.set_enabled(self.adPanel, true)
end

local function showFailedPanel(self)
	gui.set_enabled(self.adPanel, false)
	gui.set_enabled(self.failedPanel, true)
end


local function showAdBlockPanel(self)
	gui.set_enabled(self.basePanel, false)
	gui.set_enabled(self.adPanel, false)
	gui.set_enabled(self.adBlockerPanel, true)
end

local function onNoBtn(self)
	msg.post("main:/loader#loader", "restartGame")
end

local function onYesBtn(self)
	if self.adBlocked then
		showAdBlockPanel(self)
	else
		--local placement = "test_placement" -- optional
		bridge.advertisement.show_rewarded()
		
		
		--bridge.advertisement.show_interstitial()

		--crazygames.show_rewarded_ad(function(self, result)
		--	if result then
		--		upgrades.setCoins(upgrades.coins + 50)
		--		upgrades.saveUpgrades()
		--		msg.post("main:/loader#loader", "restartGame")
		--	else
		--		msg.post("main:/loader#loader", "restartGame")
		--	end
	--	end)
end
end

local function onContinue(self)
	if not self.submitting then 
		bridge.advertisement.show_interstitial()
	end
end

local function fetchHighScores(self)
	self.isFetching = true
	hideInput(self)	hideDescriptionText(self)
	gui.animate(self.loadingTextNode, "color.w", 0, gui.EASING_LINEAR, 1,0,nil,gui.PLAYBACK_LOOP_PINGPONG)
	http.request("https://tgapi-zhv2.onrender.com/scores", "GET", handle_fetch_response)
	setLoadingText(self, "Checking Highscores...", "Проверка рекордов...")
end

local function check_ad_block(self)
	self.adBlocked = false
	bridge.advertisement.check_ad_block(function (_, data)
		self.adBlocked = data
	end, 
	function ()
		-- error
	end)
end


function init(self)
	self.druid = druid.new(self)

	bridge.platform.send_message("gameplay_stopped");

	bridge.advertisement.on("rewarded_state_changed", function (_, state)
		if state == "rewarded" then 
			upgrades.setCoins(upgrades.coins + 50)
			upgrades.saveUpgrades()
			msg.post("main:/loader#loader", "restartGame")
		elseif state == "failed" then 
			showFailedPanel(self)
		elseif state == "closed" then 
			msg.post("main:/loader#loader", "restartGame")
		end
	end)

	bridge.advertisement.on("interstitial_state_changed", function (_, state)
		if state == "failed" then 
			msg.post("main:/loader#loader", "restartGame")
		elseif state == "closed" then 
			msg.post("main:/loader#loader", "restartGame")
		end
	end)

	check_ad_block(self)

	self.basePanel = gui.get_node("basePanel")
	self.adPanel = gui.get_node("adPanel")
	self.adBlockerPanel = gui.get_node("adBlockerPanel")
	self.failedPanel = gui.get_node("failedPanel")
	self.yesBtn = self.druid:new_button("yesBtn", onYesBtn)
	self.noBtn = self.druid:new_button("noBtn", onNoBtn)
	self.failedContinueBtn = self.druid:new_button("failedContinueBtn", onNoBtn)

	self.ignoreBtn = self.druid:new_button("ignoreBtn", onNoBtn)
	self.whiteListedBtn = self.druid:new_button("whiteListedBtn", onNoBtn)
	
	self.collectedCoinsText = gui.get_node("text3")
	gui.set_text(self.collectedCoinsText, "You have collected ".. tostring(gameModel.currentScores) .." coins")
	
	self.submitting = false

	self.rich_input = self.druid:new(rich_input, "rich_input")
	self.rich_input_parent = gui.get_node("rich_input_parent")
	self.rich_input:set_placeholder("Enter Your Name")
	self.rich_input.input:set_max_length(11)
	self.rich_input.input:set_allowed_characters("[A-Za-z0-9А-Яа-я]")
	--	self.rich_input:set_max_length(self,11)

	self.submitButton = self.druid:new_button("submit", onSubmit)
	self.continueButton = self.druid:new_button("continue", onContinue)
	self.submitButtonNode = gui.get_node("submit")

	self.successIcon = gui.get_node("successIcon")
	
	gui.set_text(gui.get_node("scores"), tostring(gameModel.currentScores))
	self.loadingTextNode = gui.get_node("loadingText")
	self.descriptionTextNode = gui.get_node("description")
	self.cheeringTextNode = gui.get_node("cheering")
	self.isFetching = false

	fetchHighScores(self)

	if gameSettings.lang == "ru" then
		translateToRussian(self)
	end
end

function on_input(self, action_id, action)
	if action_id == const.ACTION_TEXT or action_id == const.ACTION_MARKED_TEXT then 
		if action.text == "\n" or action.text == "\r" or action.text == "" then
			return true
		end
	end
	return self.druid:on_input(action_id, action)
end

function update(self, dt)
	self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)
end

function final(self)
	self.druid:final()
end